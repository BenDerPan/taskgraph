{"name":"Taskgraph","tagline":"A fault tolerant, distributed task driven framework","body":"TaskGraph\r\n=========\r\n\r\nTaskGraph is a framework for writing fault tolerent distributed applications. It\r\nassumes that application consists of a network of tasks, which are inter-connected\r\nbased on certain topology (hence graph). TaskGraph assume for each task (logical\r\nunit of work), there are one primary node, and zero or more backup nodes. TaskGraph\r\nthen help with two types of node failure: failure happens to nodes from different\r\ntask, failure happens to the nodes from the same task. Framework monitors the\r\ntask/node's health, and take care of restarting the failed tasks, and also pass\r\non a standard set of events (typed neighbors fail/restart, primary/backup switch)\r\nto task implementation so that it can do application dependent recovery.\r\n\r\n\r\nTaskGrpah supports an event driven pull model for communication. When one task\r\nwant to talk to some other task, it set a flag via framework, and framework will\r\nnotify recipient, which can decide whether or when to fetch data via Framework.\r\nFramework will handle communication failures via automatic retry, reconnect to\r\nnew task node, etc. In another word, it provides exactly-once semantic on data\r\nrequest.\r\n\r\n\r\nAn TaskGraph application usually has three layers. And application implementation\r\nneed to configure TaskGraph in driver layer and also implement Task/TaskBuilder/Topology\r\nbased on application logic.\r\n\r\n1. In driver (main function), applicaiton need to configure the task graph. This\r\ninclude setting up TaskBuilder, which specify what task need to run as each node.\r\nOne also need to specify the network topology which specify who connect to whom\r\nat each iteration. Then FrameWork.Start is called so that every node will get into\r\nevent loop.\r\n\r\n2. TaskGraph framework handles fault tolerency within the framework. It uses etcd\r\nand/or kubernetes for this purpose. It should also handle the communication between\r\nlogic task so that it can hide the communication between master and hot standby.\r\n\r\n3. Application need to implement Task interface, to specify how they should react\r\nto parent/child dia/restart event to carry out the correct application logic. Note\r\nthat application developer need to implement TaskBuilder/Topology that suit their\r\nneed (implementaion of these three interface are wired together in the driver).\r\n\r\nFor an example of driver and task implementation, check `example/regression`.\r\n\r\nNote, for now, the completion of TaskGraph is not defined explicitly. Instead, each\r\napplication will have their way of exit based on application dependent logic. As\r\nan example, the above application can stop if task 0 stops. We have the hooks in\r\nFramework so any node can potentially exit the entire TaskGraph. We also have hook\r\nin Task so that task implementation get a change to save the work.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}